// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package dev.sigstore.verification.v1;

import "sigstore_trustroot.proto";
import "sigstore_bundle.proto";

option go_package = "github.com/sigstore/proto/verification/v1";
option java_package = "dev.sigstore.proto.verification.v1";
option java_multiple_files = true;
option java_outer_classname = "VerificationProto";

enum SubjectAlternativeNameType {
        DNS = 0;
        Email = 1;
        URI = 2;
}

message SubjectAlternativeName {
        SubjectAlternativeNameType type = 1;
        // A regular expression describing the expected value for the SAN.
        string value = 2;
}

// The identity of a signer.
message Identity {
        // The X.509v3 issuer extension (OID 1.3.6.1.4.1.57264.1.1)
        string issuer = 1;
        oneof identity {
                SubjectAlternativeName san = 2;
        }
}

// A light-weight set of options/policies for identifying trusted signers,
// used during verification of a single artifact.
message ArtifactVerificationOptions {
        message TlogOptions {
                // Number of transparency logs the entry must appear on.
                int32 threshold = 1;
                // Perform an online inclusion proof.
                // TODO: @haydentherapper: wanna punt this for now?
                bool perform_online_verification = 2;
                // Disable verification for transparency logs.
                bool disable = 3;
        }
        message CtfeOptions {
                // The number of ct transparency logs the certificate must
                // appear on.
                int32 threshold = 1;
                // Expect detached SCTs.
                // This is not supported right now as we can't capture an
                // detached SCT in the bundle.
                bool detached_sct = 2;
                // Disable ct transparency log verification
                bool disable = 3;
        }
        message TsaOptions {
                // The number of signed timestamps that are expected.
                int32 threshold = 1;
                // Disable signed timestamp verification.
                bool disable = 2;
        }

        // At least one identity MUST be provided. Providing zero identities
        // is an error.
        repeated Identity signers = 1;
        // Optional options for artifact transparency log verification.
        // If none is provided, the default verification options are:
        // Threshold: 1
        // Online verification: false
        // Disable: false
        optional TlogOptions tlog_options = 2;
        // Optional options for certificate transparency log verification.
        // If none is provided, the default verification options are:
        // Threshold: 1
        // Detached SCT: false
        // Disable: false
        optional CtfeOptions ctfe_options = 3;
        // Optional options for certificate signed timestamp verification.
        // If none is provided, the default verification options are:
        // Threshold: 1
        // Disable: false
        optional TsaOptions tsa_options = 4;
}

message Artifact {
        oneof data {
                // Location of the artifact
                string artifact_uri = 1;
                // The raw bytes of the artifact
                bytes artifact = 2;
        }
}

// Input captures all that is needed to call the bundle verification method,
// to verify a single artifact referenced by the bundle.
message Input {
        // The verification materials provided during a bundle verification.
        // The "instance" is usually preloaded with a "resolved"
        // dev.sisgtore.trustroot.TrustedRoot.v1 instance. Prior to
        // verifying an artifact (i.e a bundle) some selection is expected
        // to happen, to filter out the exact authorities to use, which is
        // captured in this attribute.
        //
        // As there can be multiple certificate authorities and public keys
        // after the global trust root has ben filtered down to a smaller,
        // per artifact set, any implementors of the verification logic MUST
        // offer an interface where the calling client can provide a
        // function that finds the correct key/certificate authority to use,
        // as this selection is inherently  dependant on the used key
        // mechanism (e.g. a cloud KMS with a versioned key).
        // As an example the client can provide a method
        // `Verify(bytes artifact, bytes signature, string key_id)`
        // that the caller implements over the set of trusted public keys,
        // (filtered for this artifact). This way the verification code does
        // not need to deal with context depandant key selection, different
        // key types etc.
        dev.sigstore.trustroot.v1.TrustedRoot artifact_trust_root = 1;
        ArtifactVerificationOptions artifact_verification_options = 2;
        dev.sigstore.bundle.v1.Bundle bundle = 3;
        // If the bundle contains a message signature, the artifact must be
        // provided.
        optional Artifact artifact = 4;
}
