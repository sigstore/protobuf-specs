// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sigstore_verification.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct CertificateIdentity {
    // message fields
    pub issuer: ::std::string::String,
    pub san: ::protobuf::SingularPtrField<super::sigstore_common::SubjectAlternativeName>,
    pub oids: ::protobuf::RepeatedField<super::sigstore_common::ObjectIdentifierValuePair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateIdentity {
    fn default() -> &'a CertificateIdentity {
        <CertificateIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CertificateIdentity {
    pub fn new() -> CertificateIdentity {
        ::std::default::Default::default()
    }

    // string issuer = 1;


    pub fn get_issuer(&self) -> &str {
        &self.issuer
    }
    pub fn clear_issuer(&mut self) {
        self.issuer.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        &mut self.issuer
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuer, ::std::string::String::new())
    }

    // .dev.sigstore.common.v1.SubjectAlternativeName san = 2;


    pub fn get_san(&self) -> &super::sigstore_common::SubjectAlternativeName {
        self.san.as_ref().unwrap_or_else(|| <super::sigstore_common::SubjectAlternativeName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_san(&mut self) {
        self.san.clear();
    }

    pub fn has_san(&self) -> bool {
        self.san.is_some()
    }

    // Param is passed by value, moved
    pub fn set_san(&mut self, v: super::sigstore_common::SubjectAlternativeName) {
        self.san = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_san(&mut self) -> &mut super::sigstore_common::SubjectAlternativeName {
        if self.san.is_none() {
            self.san.set_default();
        }
        self.san.as_mut().unwrap()
    }

    // Take field
    pub fn take_san(&mut self) -> super::sigstore_common::SubjectAlternativeName {
        self.san.take().unwrap_or_else(|| super::sigstore_common::SubjectAlternativeName::new())
    }

    // repeated .dev.sigstore.common.v1.ObjectIdentifierValuePair oids = 3;


    pub fn get_oids(&self) -> &[super::sigstore_common::ObjectIdentifierValuePair] {
        &self.oids
    }
    pub fn clear_oids(&mut self) {
        self.oids.clear();
    }

    // Param is passed by value, moved
    pub fn set_oids(&mut self, v: ::protobuf::RepeatedField<super::sigstore_common::ObjectIdentifierValuePair>) {
        self.oids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_oids(&mut self) -> &mut ::protobuf::RepeatedField<super::sigstore_common::ObjectIdentifierValuePair> {
        &mut self.oids
    }

    // Take field
    pub fn take_oids(&mut self) -> ::protobuf::RepeatedField<super::sigstore_common::ObjectIdentifierValuePair> {
        ::std::mem::replace(&mut self.oids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CertificateIdentity {
    fn is_initialized(&self) -> bool {
        for v in &self.san {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.san)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.oids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.issuer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.issuer);
        }
        if let Some(ref v) = self.san.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.oids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.issuer.is_empty() {
            os.write_string(1, &self.issuer)?;
        }
        if let Some(ref v) = self.san.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.oids {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateIdentity {
        CertificateIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "issuer",
                |m: &CertificateIdentity| { &m.issuer },
                |m: &mut CertificateIdentity| { &mut m.issuer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::sigstore_common::SubjectAlternativeName>>(
                "san",
                |m: &CertificateIdentity| { &m.san },
                |m: &mut CertificateIdentity| { &mut m.san },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::sigstore_common::ObjectIdentifierValuePair>>(
                "oids",
                |m: &CertificateIdentity| { &m.oids },
                |m: &mut CertificateIdentity| { &mut m.oids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateIdentity>(
                "CertificateIdentity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateIdentity {
        static instance: ::protobuf::rt::LazyV2<CertificateIdentity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateIdentity::new)
    }
}

impl ::protobuf::Clear for CertificateIdentity {
    fn clear(&mut self) {
        self.issuer.clear();
        self.san.clear();
        self.oids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CertificateIdentities {
    // message fields
    pub identities: ::protobuf::RepeatedField<CertificateIdentity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateIdentities {
    fn default() -> &'a CertificateIdentities {
        <CertificateIdentities as ::protobuf::Message>::default_instance()
    }
}

impl CertificateIdentities {
    pub fn new() -> CertificateIdentities {
        ::std::default::Default::default()
    }

    // repeated .dev.sigstore.verification.v1.CertificateIdentity identities = 1;


    pub fn get_identities(&self) -> &[CertificateIdentity] {
        &self.identities
    }
    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<CertificateIdentity>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<CertificateIdentity> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<CertificateIdentity> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CertificateIdentities {
    fn is_initialized(&self) -> bool {
        for v in &self.identities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.identities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.identities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.identities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateIdentities {
        CertificateIdentities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateIdentity>>(
                "identities",
                |m: &CertificateIdentities| { &m.identities },
                |m: &mut CertificateIdentities| { &mut m.identities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateIdentities>(
                "CertificateIdentities",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateIdentities {
        static instance: ::protobuf::rt::LazyV2<CertificateIdentities> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateIdentities::new)
    }
}

impl ::protobuf::Clear for CertificateIdentities {
    fn clear(&mut self) {
        self.identities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateIdentities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateIdentities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublicKeyIdentities {
    // message fields
    pub public_keys: ::protobuf::RepeatedField<super::sigstore_common::PublicKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyIdentities {
    fn default() -> &'a PublicKeyIdentities {
        <PublicKeyIdentities as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyIdentities {
    pub fn new() -> PublicKeyIdentities {
        ::std::default::Default::default()
    }

    // repeated .dev.sigstore.common.v1.PublicKey public_keys = 1;


    pub fn get_public_keys(&self) -> &[super::sigstore_common::PublicKey] {
        &self.public_keys
    }
    pub fn clear_public_keys(&mut self) {
        self.public_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_keys(&mut self, v: ::protobuf::RepeatedField<super::sigstore_common::PublicKey>) {
        self.public_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_public_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::sigstore_common::PublicKey> {
        &mut self.public_keys
    }

    // Take field
    pub fn take_public_keys(&mut self) -> ::protobuf::RepeatedField<super::sigstore_common::PublicKey> {
        ::std::mem::replace(&mut self.public_keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublicKeyIdentities {
    fn is_initialized(&self) -> bool {
        for v in &self.public_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.public_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.public_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.public_keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyIdentities {
        PublicKeyIdentities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::sigstore_common::PublicKey>>(
                "public_keys",
                |m: &PublicKeyIdentities| { &m.public_keys },
                |m: &mut PublicKeyIdentities| { &mut m.public_keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PublicKeyIdentities>(
                "PublicKeyIdentities",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PublicKeyIdentities {
        static instance: ::protobuf::rt::LazyV2<PublicKeyIdentities> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyIdentities::new)
    }
}

impl ::protobuf::Clear for PublicKeyIdentities {
    fn clear(&mut self) {
        self.public_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublicKeyIdentities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyIdentities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactVerificationOptions {
    // message oneof groups
    pub signers: ::std::option::Option<ArtifactVerificationOptions_oneof_signers>,
    pub _tlog_options: ::std::option::Option<ArtifactVerificationOptions_oneof__tlog_options>,
    pub _ctlog_options: ::std::option::Option<ArtifactVerificationOptions_oneof__ctlog_options>,
    pub _tsa_options: ::std::option::Option<ArtifactVerificationOptions_oneof__tsa_options>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactVerificationOptions {
    fn default() -> &'a ArtifactVerificationOptions {
        <ArtifactVerificationOptions as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ArtifactVerificationOptions_oneof_signers {
    certificate_identities(CertificateIdentities),
    public_keys(PublicKeyIdentities),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ArtifactVerificationOptions_oneof__tlog_options {
    tlog_options(ArtifactVerificationOptions_TlogOptions),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ArtifactVerificationOptions_oneof__ctlog_options {
    ctlog_options(ArtifactVerificationOptions_CtlogOptions),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ArtifactVerificationOptions_oneof__tsa_options {
    tsa_options(ArtifactVerificationOptions_TimestampAuthorityOptions),
}

impl ArtifactVerificationOptions {
    pub fn new() -> ArtifactVerificationOptions {
        ::std::default::Default::default()
    }

    // .dev.sigstore.verification.v1.CertificateIdentities certificate_identities = 1;


    pub fn get_certificate_identities(&self) -> &CertificateIdentities {
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(ref v)) => v,
            _ => <CertificateIdentities as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_certificate_identities(&mut self) {
        self.signers = ::std::option::Option::None;
    }

    pub fn has_certificate_identities(&self) -> bool {
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_certificate_identities(&mut self, v: CertificateIdentities) {
        self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(v))
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_identities(&mut self) -> &mut CertificateIdentities {
        if let ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(_)) = self.signers {
        } else {
            self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(CertificateIdentities::new()));
        }
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_certificate_identities(&mut self) -> CertificateIdentities {
        if self.has_certificate_identities() {
            match self.signers.take() {
                ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(v)) => v,
                _ => panic!(),
            }
        } else {
            CertificateIdentities::new()
        }
    }

    // .dev.sigstore.verification.v1.PublicKeyIdentities public_keys = 2;


    pub fn get_public_keys(&self) -> &PublicKeyIdentities {
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(ref v)) => v,
            _ => <PublicKeyIdentities as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_public_keys(&mut self) {
        self.signers = ::std::option::Option::None;
    }

    pub fn has_public_keys(&self) -> bool {
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_public_keys(&mut self, v: PublicKeyIdentities) {
        self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(v))
    }

    // Mutable pointer to the field.
    pub fn mut_public_keys(&mut self) -> &mut PublicKeyIdentities {
        if let ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(_)) = self.signers {
        } else {
            self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(PublicKeyIdentities::new()));
        }
        match self.signers {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_public_keys(&mut self) -> PublicKeyIdentities {
        if self.has_public_keys() {
            match self.signers.take() {
                ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(v)) => v,
                _ => panic!(),
            }
        } else {
            PublicKeyIdentities::new()
        }
    }

    // .dev.sigstore.verification.v1.ArtifactVerificationOptions.TlogOptions tlog_options = 3;


    pub fn get_tlog_options(&self) -> &ArtifactVerificationOptions_TlogOptions {
        match self._tlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ref v)) => v,
            _ => <ArtifactVerificationOptions_TlogOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tlog_options(&mut self) {
        self._tlog_options = ::std::option::Option::None;
    }

    pub fn has_tlog_options(&self) -> bool {
        match self._tlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tlog_options(&mut self, v: ArtifactVerificationOptions_TlogOptions) {
        self._tlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tlog_options(&mut self) -> &mut ArtifactVerificationOptions_TlogOptions {
        if let ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(_)) = self._tlog_options {
        } else {
            self._tlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ArtifactVerificationOptions_TlogOptions::new()));
        }
        match self._tlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tlog_options(&mut self) -> ArtifactVerificationOptions_TlogOptions {
        if self.has_tlog_options() {
            match self._tlog_options.take() {
                ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtifactVerificationOptions_TlogOptions::new()
        }
    }

    // .dev.sigstore.verification.v1.ArtifactVerificationOptions.CtlogOptions ctlog_options = 4;


    pub fn get_ctlog_options(&self) -> &ArtifactVerificationOptions_CtlogOptions {
        match self._ctlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ref v)) => v,
            _ => <ArtifactVerificationOptions_CtlogOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ctlog_options(&mut self) {
        self._ctlog_options = ::std::option::Option::None;
    }

    pub fn has_ctlog_options(&self) -> bool {
        match self._ctlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ctlog_options(&mut self, v: ArtifactVerificationOptions_CtlogOptions) {
        self._ctlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ctlog_options(&mut self) -> &mut ArtifactVerificationOptions_CtlogOptions {
        if let ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(_)) = self._ctlog_options {
        } else {
            self._ctlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ArtifactVerificationOptions_CtlogOptions::new()));
        }
        match self._ctlog_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ctlog_options(&mut self) -> ArtifactVerificationOptions_CtlogOptions {
        if self.has_ctlog_options() {
            match self._ctlog_options.take() {
                ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtifactVerificationOptions_CtlogOptions::new()
        }
    }

    // .dev.sigstore.verification.v1.ArtifactVerificationOptions.TimestampAuthorityOptions tsa_options = 5;


    pub fn get_tsa_options(&self) -> &ArtifactVerificationOptions_TimestampAuthorityOptions {
        match self._tsa_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ref v)) => v,
            _ => <ArtifactVerificationOptions_TimestampAuthorityOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tsa_options(&mut self) {
        self._tsa_options = ::std::option::Option::None;
    }

    pub fn has_tsa_options(&self) -> bool {
        match self._tsa_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tsa_options(&mut self, v: ArtifactVerificationOptions_TimestampAuthorityOptions) {
        self._tsa_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tsa_options(&mut self) -> &mut ArtifactVerificationOptions_TimestampAuthorityOptions {
        if let ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(_)) = self._tsa_options {
        } else {
            self._tsa_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ArtifactVerificationOptions_TimestampAuthorityOptions::new()));
        }
        match self._tsa_options {
            ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tsa_options(&mut self) -> ArtifactVerificationOptions_TimestampAuthorityOptions {
        if self.has_tsa_options() {
            match self._tsa_options.take() {
                ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtifactVerificationOptions_TimestampAuthorityOptions::new()
        }
    }
}

impl ::protobuf::Message for ArtifactVerificationOptions {
    fn is_initialized(&self) -> bool {
        if let Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(ref v)) = self.signers {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactVerificationOptions_oneof_signers::public_keys(ref v)) = self.signers {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ref v)) = self._tlog_options {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ref v)) = self._ctlog_options {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ref v)) = self._tsa_options {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::certificate_identities(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signers = ::std::option::Option::Some(ArtifactVerificationOptions_oneof_signers::public_keys(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._tlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tlog_options::tlog_options(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._ctlog_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._tsa_options = ::std::option::Option::Some(ArtifactVerificationOptions_oneof__tsa_options::tsa_options(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.signers {
            match v {
                &ArtifactVerificationOptions_oneof_signers::certificate_identities(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ArtifactVerificationOptions_oneof_signers::public_keys(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tlog_options {
            match v {
                &ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._ctlog_options {
            match v {
                &ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tsa_options {
            match v {
                &ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.signers {
            match v {
                &ArtifactVerificationOptions_oneof_signers::certificate_identities(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ArtifactVerificationOptions_oneof_signers::public_keys(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tlog_options {
            match v {
                &ArtifactVerificationOptions_oneof__tlog_options::tlog_options(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._ctlog_options {
            match v {
                &ArtifactVerificationOptions_oneof__ctlog_options::ctlog_options(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._tsa_options {
            match v {
                &ArtifactVerificationOptions_oneof__tsa_options::tsa_options(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactVerificationOptions {
        ArtifactVerificationOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CertificateIdentities>(
                "certificate_identities",
                ArtifactVerificationOptions::has_certificate_identities,
                ArtifactVerificationOptions::get_certificate_identities,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PublicKeyIdentities>(
                "public_keys",
                ArtifactVerificationOptions::has_public_keys,
                ArtifactVerificationOptions::get_public_keys,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArtifactVerificationOptions_TlogOptions>(
                "tlog_options",
                ArtifactVerificationOptions::has_tlog_options,
                ArtifactVerificationOptions::get_tlog_options,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArtifactVerificationOptions_CtlogOptions>(
                "ctlog_options",
                ArtifactVerificationOptions::has_ctlog_options,
                ArtifactVerificationOptions::get_ctlog_options,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArtifactVerificationOptions_TimestampAuthorityOptions>(
                "tsa_options",
                ArtifactVerificationOptions::has_tsa_options,
                ArtifactVerificationOptions::get_tsa_options,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtifactVerificationOptions>(
                "ArtifactVerificationOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtifactVerificationOptions {
        static instance: ::protobuf::rt::LazyV2<ArtifactVerificationOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtifactVerificationOptions::new)
    }
}

impl ::protobuf::Clear for ArtifactVerificationOptions {
    fn clear(&mut self) {
        self.signers = ::std::option::Option::None;
        self.signers = ::std::option::Option::None;
        self._tlog_options = ::std::option::Option::None;
        self._ctlog_options = ::std::option::Option::None;
        self._tsa_options = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactVerificationOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactVerificationOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactVerificationOptions_TlogOptions {
    // message fields
    pub threshold: i32,
    pub perform_online_verification: bool,
    pub disable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactVerificationOptions_TlogOptions {
    fn default() -> &'a ArtifactVerificationOptions_TlogOptions {
        <ArtifactVerificationOptions_TlogOptions as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactVerificationOptions_TlogOptions {
    pub fn new() -> ArtifactVerificationOptions_TlogOptions {
        ::std::default::Default::default()
    }

    // int32 threshold = 1;


    pub fn get_threshold(&self) -> i32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i32) {
        self.threshold = v;
    }

    // bool perform_online_verification = 2;


    pub fn get_perform_online_verification(&self) -> bool {
        self.perform_online_verification
    }
    pub fn clear_perform_online_verification(&mut self) {
        self.perform_online_verification = false;
    }

    // Param is passed by value, moved
    pub fn set_perform_online_verification(&mut self, v: bool) {
        self.perform_online_verification = v;
    }

    // bool disable = 3;


    pub fn get_disable(&self) -> bool {
        self.disable
    }
    pub fn clear_disable(&mut self) {
        self.disable = false;
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = v;
    }
}

impl ::protobuf::Message for ArtifactVerificationOptions_TlogOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threshold = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perform_online_verification = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.perform_online_verification != false {
            my_size += 2;
        }
        if self.disable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0 {
            os.write_int32(1, self.threshold)?;
        }
        if self.perform_online_verification != false {
            os.write_bool(2, self.perform_online_verification)?;
        }
        if self.disable != false {
            os.write_bool(3, self.disable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactVerificationOptions_TlogOptions {
        ArtifactVerificationOptions_TlogOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threshold",
                |m: &ArtifactVerificationOptions_TlogOptions| { &m.threshold },
                |m: &mut ArtifactVerificationOptions_TlogOptions| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "perform_online_verification",
                |m: &ArtifactVerificationOptions_TlogOptions| { &m.perform_online_verification },
                |m: &mut ArtifactVerificationOptions_TlogOptions| { &mut m.perform_online_verification },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable",
                |m: &ArtifactVerificationOptions_TlogOptions| { &m.disable },
                |m: &mut ArtifactVerificationOptions_TlogOptions| { &mut m.disable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtifactVerificationOptions_TlogOptions>(
                "ArtifactVerificationOptions.TlogOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtifactVerificationOptions_TlogOptions {
        static instance: ::protobuf::rt::LazyV2<ArtifactVerificationOptions_TlogOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtifactVerificationOptions_TlogOptions::new)
    }
}

impl ::protobuf::Clear for ArtifactVerificationOptions_TlogOptions {
    fn clear(&mut self) {
        self.threshold = 0;
        self.perform_online_verification = false;
        self.disable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactVerificationOptions_TlogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactVerificationOptions_TlogOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactVerificationOptions_CtlogOptions {
    // message fields
    pub threshold: i32,
    pub detached_sct: bool,
    pub disable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactVerificationOptions_CtlogOptions {
    fn default() -> &'a ArtifactVerificationOptions_CtlogOptions {
        <ArtifactVerificationOptions_CtlogOptions as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactVerificationOptions_CtlogOptions {
    pub fn new() -> ArtifactVerificationOptions_CtlogOptions {
        ::std::default::Default::default()
    }

    // int32 threshold = 1;


    pub fn get_threshold(&self) -> i32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i32) {
        self.threshold = v;
    }

    // bool detached_sct = 2;


    pub fn get_detached_sct(&self) -> bool {
        self.detached_sct
    }
    pub fn clear_detached_sct(&mut self) {
        self.detached_sct = false;
    }

    // Param is passed by value, moved
    pub fn set_detached_sct(&mut self, v: bool) {
        self.detached_sct = v;
    }

    // bool disable = 3;


    pub fn get_disable(&self) -> bool {
        self.disable
    }
    pub fn clear_disable(&mut self) {
        self.disable = false;
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = v;
    }
}

impl ::protobuf::Message for ArtifactVerificationOptions_CtlogOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threshold = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached_sct = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.detached_sct != false {
            my_size += 2;
        }
        if self.disable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0 {
            os.write_int32(1, self.threshold)?;
        }
        if self.detached_sct != false {
            os.write_bool(2, self.detached_sct)?;
        }
        if self.disable != false {
            os.write_bool(3, self.disable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactVerificationOptions_CtlogOptions {
        ArtifactVerificationOptions_CtlogOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threshold",
                |m: &ArtifactVerificationOptions_CtlogOptions| { &m.threshold },
                |m: &mut ArtifactVerificationOptions_CtlogOptions| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detached_sct",
                |m: &ArtifactVerificationOptions_CtlogOptions| { &m.detached_sct },
                |m: &mut ArtifactVerificationOptions_CtlogOptions| { &mut m.detached_sct },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable",
                |m: &ArtifactVerificationOptions_CtlogOptions| { &m.disable },
                |m: &mut ArtifactVerificationOptions_CtlogOptions| { &mut m.disable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtifactVerificationOptions_CtlogOptions>(
                "ArtifactVerificationOptions.CtlogOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtifactVerificationOptions_CtlogOptions {
        static instance: ::protobuf::rt::LazyV2<ArtifactVerificationOptions_CtlogOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtifactVerificationOptions_CtlogOptions::new)
    }
}

impl ::protobuf::Clear for ArtifactVerificationOptions_CtlogOptions {
    fn clear(&mut self) {
        self.threshold = 0;
        self.detached_sct = false;
        self.disable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactVerificationOptions_CtlogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactVerificationOptions_CtlogOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtifactVerificationOptions_TimestampAuthorityOptions {
    // message fields
    pub threshold: i32,
    pub disable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtifactVerificationOptions_TimestampAuthorityOptions {
    fn default() -> &'a ArtifactVerificationOptions_TimestampAuthorityOptions {
        <ArtifactVerificationOptions_TimestampAuthorityOptions as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactVerificationOptions_TimestampAuthorityOptions {
    pub fn new() -> ArtifactVerificationOptions_TimestampAuthorityOptions {
        ::std::default::Default::default()
    }

    // int32 threshold = 1;


    pub fn get_threshold(&self) -> i32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i32) {
        self.threshold = v;
    }

    // bool disable = 2;


    pub fn get_disable(&self) -> bool {
        self.disable
    }
    pub fn clear_disable(&mut self) {
        self.disable = false;
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = v;
    }
}

impl ::protobuf::Message for ArtifactVerificationOptions_TimestampAuthorityOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threshold = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0 {
            os.write_int32(1, self.threshold)?;
        }
        if self.disable != false {
            os.write_bool(2, self.disable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtifactVerificationOptions_TimestampAuthorityOptions {
        ArtifactVerificationOptions_TimestampAuthorityOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threshold",
                |m: &ArtifactVerificationOptions_TimestampAuthorityOptions| { &m.threshold },
                |m: &mut ArtifactVerificationOptions_TimestampAuthorityOptions| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable",
                |m: &ArtifactVerificationOptions_TimestampAuthorityOptions| { &m.disable },
                |m: &mut ArtifactVerificationOptions_TimestampAuthorityOptions| { &mut m.disable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtifactVerificationOptions_TimestampAuthorityOptions>(
                "ArtifactVerificationOptions.TimestampAuthorityOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtifactVerificationOptions_TimestampAuthorityOptions {
        static instance: ::protobuf::rt::LazyV2<ArtifactVerificationOptions_TimestampAuthorityOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtifactVerificationOptions_TimestampAuthorityOptions::new)
    }
}

impl ::protobuf::Clear for ArtifactVerificationOptions_TimestampAuthorityOptions {
    fn clear(&mut self) {
        self.threshold = 0;
        self.disable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtifactVerificationOptions_TimestampAuthorityOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactVerificationOptions_TimestampAuthorityOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Artifact {
    // message oneof groups
    pub data: ::std::option::Option<Artifact_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Artifact {
    fn default() -> &'a Artifact {
        <Artifact as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Artifact_oneof_data {
    artifact_uri(::std::string::String),
    artifact(::std::vec::Vec<u8>),
}

impl Artifact {
    pub fn new() -> Artifact {
        ::std::default::Default::default()
    }

    // string artifact_uri = 1;


    pub fn get_artifact_uri(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_artifact_uri(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_artifact_uri(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_uri(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_uri(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_uri(&mut self) -> ::std::string::String {
        if self.has_artifact_uri() {
            match self.data.take() {
                ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes artifact = 2;


    pub fn get_artifact(&self) -> &[u8] {
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_artifact(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_artifact(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Artifact_oneof_data::artifact(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact(::std::vec::Vec::new()));
        }
        match self.data {
            ::std::option::Option::Some(Artifact_oneof_data::artifact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_artifact() {
            match self.data.take() {
                ::std::option::Option::Some(Artifact_oneof_data::artifact(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for Artifact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact_uri(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Artifact_oneof_data::artifact(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Artifact_oneof_data::artifact_uri(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &Artifact_oneof_data::artifact(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Artifact_oneof_data::artifact_uri(ref v) => {
                    os.write_string(1, v)?;
                },
                &Artifact_oneof_data::artifact(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Artifact {
        Artifact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "artifact_uri",
                Artifact::has_artifact_uri,
                Artifact::get_artifact_uri,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "artifact",
                Artifact::has_artifact,
                Artifact::get_artifact,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Artifact>(
                "Artifact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Artifact {
        static instance: ::protobuf::rt::LazyV2<Artifact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Artifact::new)
    }
}

impl ::protobuf::Clear for Artifact {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Artifact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artifact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Input {
    // message fields
    pub artifact_trust_root: ::protobuf::SingularPtrField<super::sigstore_trustroot::TrustedRoot>,
    pub artifact_verification_options: ::protobuf::SingularPtrField<ArtifactVerificationOptions>,
    pub bundle: ::protobuf::SingularPtrField<super::sigstore_bundle::Bundle>,
    // message oneof groups
    pub _artifact: ::std::option::Option<Input_oneof__artifact>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Input {
    fn default() -> &'a Input {
        <Input as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Input_oneof__artifact {
    artifact(Artifact),
}

impl Input {
    pub fn new() -> Input {
        ::std::default::Default::default()
    }

    // .dev.sigstore.trustroot.v1.TrustedRoot artifact_trust_root = 1;


    pub fn get_artifact_trust_root(&self) -> &super::sigstore_trustroot::TrustedRoot {
        self.artifact_trust_root.as_ref().unwrap_or_else(|| <super::sigstore_trustroot::TrustedRoot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_artifact_trust_root(&mut self) {
        self.artifact_trust_root.clear();
    }

    pub fn has_artifact_trust_root(&self) -> bool {
        self.artifact_trust_root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artifact_trust_root(&mut self, v: super::sigstore_trustroot::TrustedRoot) {
        self.artifact_trust_root = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact_trust_root(&mut self) -> &mut super::sigstore_trustroot::TrustedRoot {
        if self.artifact_trust_root.is_none() {
            self.artifact_trust_root.set_default();
        }
        self.artifact_trust_root.as_mut().unwrap()
    }

    // Take field
    pub fn take_artifact_trust_root(&mut self) -> super::sigstore_trustroot::TrustedRoot {
        self.artifact_trust_root.take().unwrap_or_else(|| super::sigstore_trustroot::TrustedRoot::new())
    }

    // .dev.sigstore.verification.v1.ArtifactVerificationOptions artifact_verification_options = 2;


    pub fn get_artifact_verification_options(&self) -> &ArtifactVerificationOptions {
        self.artifact_verification_options.as_ref().unwrap_or_else(|| <ArtifactVerificationOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_artifact_verification_options(&mut self) {
        self.artifact_verification_options.clear();
    }

    pub fn has_artifact_verification_options(&self) -> bool {
        self.artifact_verification_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artifact_verification_options(&mut self, v: ArtifactVerificationOptions) {
        self.artifact_verification_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact_verification_options(&mut self) -> &mut ArtifactVerificationOptions {
        if self.artifact_verification_options.is_none() {
            self.artifact_verification_options.set_default();
        }
        self.artifact_verification_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_artifact_verification_options(&mut self) -> ArtifactVerificationOptions {
        self.artifact_verification_options.take().unwrap_or_else(|| ArtifactVerificationOptions::new())
    }

    // .dev.sigstore.bundle.v1.Bundle bundle = 3;


    pub fn get_bundle(&self) -> &super::sigstore_bundle::Bundle {
        self.bundle.as_ref().unwrap_or_else(|| <super::sigstore_bundle::Bundle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bundle(&mut self) {
        self.bundle.clear();
    }

    pub fn has_bundle(&self) -> bool {
        self.bundle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bundle(&mut self, v: super::sigstore_bundle::Bundle) {
        self.bundle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bundle(&mut self) -> &mut super::sigstore_bundle::Bundle {
        if self.bundle.is_none() {
            self.bundle.set_default();
        }
        self.bundle.as_mut().unwrap()
    }

    // Take field
    pub fn take_bundle(&mut self) -> super::sigstore_bundle::Bundle {
        self.bundle.take().unwrap_or_else(|| super::sigstore_bundle::Bundle::new())
    }

    // .dev.sigstore.verification.v1.Artifact artifact = 4;


    pub fn get_artifact(&self) -> &Artifact {
        match self._artifact {
            ::std::option::Option::Some(Input_oneof__artifact::artifact(ref v)) => v,
            _ => <Artifact as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_artifact(&mut self) {
        self._artifact = ::std::option::Option::None;
    }

    pub fn has_artifact(&self) -> bool {
        match self._artifact {
            ::std::option::Option::Some(Input_oneof__artifact::artifact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact(&mut self, v: Artifact) {
        self._artifact = ::std::option::Option::Some(Input_oneof__artifact::artifact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact(&mut self) -> &mut Artifact {
        if let ::std::option::Option::Some(Input_oneof__artifact::artifact(_)) = self._artifact {
        } else {
            self._artifact = ::std::option::Option::Some(Input_oneof__artifact::artifact(Artifact::new()));
        }
        match self._artifact {
            ::std::option::Option::Some(Input_oneof__artifact::artifact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact(&mut self) -> Artifact {
        if self.has_artifact() {
            match self._artifact.take() {
                ::std::option::Option::Some(Input_oneof__artifact::artifact(v)) => v,
                _ => panic!(),
            }
        } else {
            Artifact::new()
        }
    }
}

impl ::protobuf::Message for Input {
    fn is_initialized(&self) -> bool {
        for v in &self.artifact_trust_root {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artifact_verification_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bundle {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Input_oneof__artifact::artifact(ref v)) = self._artifact {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artifact_trust_root)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artifact_verification_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bundle)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._artifact = ::std::option::Option::Some(Input_oneof__artifact::artifact(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.artifact_trust_root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.artifact_verification_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bundle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self._artifact {
            match v {
                &Input_oneof__artifact::artifact(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.artifact_trust_root.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.artifact_verification_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bundle.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self._artifact {
            match v {
                &Input_oneof__artifact::artifact(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Input {
        Input::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::sigstore_trustroot::TrustedRoot>>(
                "artifact_trust_root",
                |m: &Input| { &m.artifact_trust_root },
                |m: &mut Input| { &mut m.artifact_trust_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtifactVerificationOptions>>(
                "artifact_verification_options",
                |m: &Input| { &m.artifact_verification_options },
                |m: &mut Input| { &mut m.artifact_verification_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::sigstore_bundle::Bundle>>(
                "bundle",
                |m: &Input| { &m.bundle },
                |m: &mut Input| { &mut m.bundle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Artifact>(
                "artifact",
                Input::has_artifact,
                Input::get_artifact,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Input>(
                "Input",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Input {
        static instance: ::protobuf::rt::LazyV2<Input> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Input::new)
    }
}

impl ::protobuf::Clear for Input {
    fn clear(&mut self) {
        self.artifact_trust_root.clear();
        self.artifact_verification_options.clear();
        self.bundle.clear();
        self._artifact = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Input {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bsigstore_verification.proto\x12\x1cdev.sigstore.verification.v1\
    \x1a\x15sigstore_common.proto\x1a\x18sigstore_trustroot.proto\x1a\x15sig\
    store_bundle.proto\"\xb6\x01\n\x13CertificateIdentity\x12\x16\n\x06issue\
    r\x18\x01\x20\x01(\tR\x06issuer\x12@\n\x03san\x18\x02\x20\x01(\x0b2..dev\
    .sigstore.common.v1.SubjectAlternativeNameR\x03san\x12E\n\x04oids\x18\
    \x03\x20\x03(\x0b21.dev.sigstore.common.v1.ObjectIdentifierValuePairR\
    \x04oids\"j\n\x15CertificateIdentities\x12Q\n\nidentities\x18\x01\x20\
    \x03(\x0b21.dev.sigstore.verification.v1.CertificateIdentityR\nidentitie\
    s\"Y\n\x13PublicKeyIdentities\x12B\n\x0bpublic_keys\x18\x01\x20\x03(\x0b\
    2!.dev.sigstore.common.v1.PublicKeyR\npublicKeys\"\xc3\x07\n\x1bArtifact\
    VerificationOptions\x12l\n\x16certificate_identities\x18\x01\x20\x01(\
    \x0b23.dev.sigstore.verification.v1.CertificateIdentitiesH\0R\x15certifi\
    cateIdentities\x12T\n\x0bpublic_keys\x18\x02\x20\x01(\x0b21.dev.sigstore\
    .verification.v1.PublicKeyIdentitiesH\0R\npublicKeys\x12m\n\x0ctlog_opti\
    ons\x18\x03\x20\x01(\x0b2E.dev.sigstore.verification.v1.ArtifactVerifica\
    tionOptions.TlogOptionsH\x01R\x0btlogOptions\x88\x01\x01\x12p\n\rctlog_o\
    ptions\x18\x04\x20\x01(\x0b2F.dev.sigstore.verification.v1.ArtifactVerif\
    icationOptions.CtlogOptionsH\x02R\x0cctlogOptions\x88\x01\x01\x12y\n\x0b\
    tsa_options\x18\x05\x20\x01(\x0b2S.dev.sigstore.verification.v1.Artifact\
    VerificationOptions.TimestampAuthorityOptionsH\x03R\ntsaOptions\x88\x01\
    \x01\x1a\x85\x01\n\x0bTlogOptions\x12\x1c\n\tthreshold\x18\x01\x20\x01(\
    \x05R\tthreshold\x12>\n\x1bperform_online_verification\x18\x02\x20\x01(\
    \x08R\x19performOnlineVerification\x12\x18\n\x07disable\x18\x03\x20\x01(\
    \x08R\x07disable\x1ai\n\x0cCtlogOptions\x12\x1c\n\tthreshold\x18\x01\x20\
    \x01(\x05R\tthreshold\x12!\n\x0cdetached_sct\x18\x02\x20\x01(\x08R\x0bde\
    tachedSct\x12\x18\n\x07disable\x18\x03\x20\x01(\x08R\x07disable\x1aS\n\
    \x19TimestampAuthorityOptions\x12\x1c\n\tthreshold\x18\x01\x20\x01(\x05R\
    \tthreshold\x12\x18\n\x07disable\x18\x02\x20\x01(\x08R\x07disableB\t\n\
    \x07signersB\x0f\n\r_tlog_optionsB\x10\n\x0e_ctlog_optionsB\x0e\n\x0c_ts\
    a_options\"U\n\x08Artifact\x12#\n\x0cartifact_uri\x18\x01\x20\x01(\tH\0R\
    \x0bartifactUri\x12\x1c\n\x08artifact\x18\x02\x20\x01(\x0cH\0R\x08artifa\
    ctB\x06\n\x04data\"\xec\x02\n\x05Input\x12V\n\x13artifact_trust_root\x18\
    \x01\x20\x01(\x0b2&.dev.sigstore.trustroot.v1.TrustedRootR\x11artifactTr\
    ustRoot\x12}\n\x1dartifact_verification_options\x18\x02\x20\x01(\x0b29.d\
    ev.sigstore.verification.v1.ArtifactVerificationOptionsR\x1bartifactVeri\
    ficationOptions\x126\n\x06bundle\x18\x03\x20\x01(\x0b2\x1e.dev.sigstore.\
    bundle.v1.BundleR\x06bundle\x12G\n\x08artifact\x18\x04\x20\x01(\x0b2&.de\
    v.sigstore.verification.v1.ArtifactH\0R\x08artifact\x88\x01\x01B\x0b\n\t\
    _artifactBw\n\"dev.sigstore.proto.verification.v1B\x11VerificationProtoP\
    \x01Z<github.com/sigstore/protobuf-specs/gen/pb-go/verification/v1b\x06p\
    roto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
