/// TransparencyLogInstance describes the immutable parameters from a
/// transparency log.
/// See <https://www.rfc-editor.org/rfc/rfc9162.html#name-log-parameters>
/// for more details.
/// The included parameters are the minimal set required to identify a log,
/// and verify an inclusion proof/promise.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransparencyLogInstance {
    /// The base URL at which can be used to URLs for the client.
    #[prost(string, tag = "1")]
    pub base_url: ::prost::alloc::string::String,
    /// The hash algorithm used for the Merkle Tree.
    #[prost(enumeration = "super::super::common::v1::HashAlgorithm", tag = "2")]
    pub hash_algorithm: i32,
    /// The public key used to verify signatures generated by the log.
    /// This attribute contains the signature algorithm used by the log.
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<super::super::common::v1::PublicKey>,
    /// The unique identifier for this transparency log.
    #[prost(message, optional, tag = "4")]
    pub log_id: ::core::option::Option<super::super::common::v1::LogId>,
}
/// CertificateAuthority enlists the information required to identify which
/// CA to use and perform signature verification.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateAuthority {
    /// The root certificate MUST be self-signed, and so the subject and
    /// issuer are the same.
    #[prost(message, optional, tag = "1")]
    pub subject: ::core::option::Option<super::super::common::v1::DistinguishedName>,
    /// The URI at which the CA can be accessed.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// The certificate chain for this CA.
    #[prost(message, optional, tag = "3")]
    pub cert_chain: ::core::option::Option<
        super::super::common::v1::X509CertificateChain,
    >,
    /// The time the *entire* chain was valid. This is at max the
    /// longest interval when *all* certificates in the chain were valid,
    /// but it MAY be shorter. Clients MUST check timestamps against *both*
    /// the `valid_for` time range *and* the entire certificate chain.
    ///
    /// The TimeRange should be considered valid *inclusive* of the
    /// endpoints.
    #[prost(message, optional, tag = "4")]
    pub valid_for: ::core::option::Option<super::super::common::v1::TimeRange>,
}
/// TrustedRoot describes the client's complete set of trusted entities.
/// How the TrustedRoot is populated is not specified, but can be a
/// combination of many sources such as TUF repositories, files on disk etc.
///
/// The TrustedRoot is not meant to be used for any artifact verification, only
/// to capture the complete/global set of trusted verification materials.
/// When verifying an artifact, based on the artifact and policies, a selection
/// of keys/authorities are expected to be extracted and provided to the
/// verification function. This way the set of keys/authorities can be kept to
/// a minimal set by the policy to gain better control over what signatures
/// that are allowed.
///
/// The embedded transparency logs, CT logs, CAs and TSAs MUST include any
/// previously used instance -- otherwise signatures made in the past cannot
/// be verified.
/// The currently used instances MUST NOT have their 'end' timestamp set in
/// their 'valid_for' attribute for easy identification.
/// All the listed instances SHOULD be sorted by the 'valid_for' in ascending
/// order, that is, the oldest instance first and the current instance last.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustedRoot {
    /// MUST be application/vnd.dev.sigstore.trustedroot+json;version=0.1
    #[prost(string, tag = "1")]
    pub media_type: ::prost::alloc::string::String,
    /// A set of trusted Rekor servers.
    #[prost(message, repeated, tag = "2")]
    pub tlogs: ::prost::alloc::vec::Vec<TransparencyLogInstance>,
    /// A set of trusted certificate authorities (e.g Fulcio), and any
    /// intermediate certificates they provide.
    /// If a CA is issuing multiple intermediate certificate, each
    /// combination shall be represented as separate chain. I.e, a single
    /// root cert may appear in multiple chains but with different
    /// intermediate and/or leaf certificates.
    /// The certificates are intended to be used for verifying artifact
    /// signatures.
    #[prost(message, repeated, tag = "3")]
    pub certificate_authorities: ::prost::alloc::vec::Vec<CertificateAuthority>,
    /// A set of trusted certificate transparency logs.
    #[prost(message, repeated, tag = "4")]
    pub ctlogs: ::prost::alloc::vec::Vec<TransparencyLogInstance>,
    /// A set of trusted timestamping authorities.
    #[prost(message, repeated, tag = "5")]
    pub timestamp_authorities: ::prost::alloc::vec::Vec<CertificateAuthority>,
}
